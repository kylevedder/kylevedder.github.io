<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLY File Viewer with Trajectory Trail</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #333;
        }
        #render-container {
            width: 800px;
            height: 600px;
            border: 1px solid #ccc;
            margin-top: 20px;
        }
        #slider-container {
            width: 800px;
            margin-top: 20px;
            display: flex;
            align-items: center;
        }
        #frame-slider {
            flex-grow: 1;
            margin-right: 10px;
        }
        #frame-number {
            width: 50px;
            text-align: right;
        }
    </style>
</head>
<body>
    <h1>PLY File Viewer with Trajectory Trail</h1>
    <div id="render-container"></div>
    <div id="slider-container">
        <input type="range" id="frame-slider" min="0" max="18" value="0">
        <span id="frame-number">0</span>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

        const scene = new THREE.Scene();
        const container = document.getElementById('render-container');
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 0, 10);
        scene.add(light);

        let currentPoints = null;
        let trajectorySphereMesh = null;
        let trailSphereMeshes = [];
        let trailLine = null;
        let isFirstLoad = true;
        let trajectoryData = null;

        const slider = document.getElementById('frame-slider');
        const frameNumber = document.getElementById('frame-number');

        // Load trajectory data
        fetch('img/static/gigachad/raw_data/jack_spinning/trajectory.json')
            .then(response => response.json())
            .then(data => {
                trajectoryData = data;
                loadPLY(0); // Initial load after trajectory data is available
            })
            .catch(error => console.error('Error loading trajectory data:', error));

        function padNumber(number) {
            return number.toString().padStart(4, '0');
        }

        function loadPLY(frameIndex) {
            const fileName = `img/static/gigachad/raw_data/jack_spinning/${padNumber(frameIndex)}.ply`;
            const loader = new PLYLoader();

            loader.load(fileName, function(geometry) {
                if (currentPoints) {
                    scene.remove(currentPoints);
                }

                const material = new THREE.PointsMaterial({ size: 0.01, vertexColors: true });
                const points = new THREE.Points(geometry, material);
                
                scene.add(points);
                currentPoints = points;

                if (isFirstLoad) {
                    // Center the model
                    const box = new THREE.Box3().setFromObject(points);
                    const center = box.getCenter(new THREE.Vector3());
                    points.position.sub(center);

                    // Set up the camera with negated X and +Z up, zoomed in 3x
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const distance = maxDim * 2 / 3;
                    const angle = Math.PI / 8; // 45 degrees in radians
                    camera.position.set(
                        -distance * Math.cos(angle),
                        -distance * Math.sin(angle),
                        distance * 0.5
                    );
                    camera.up.set(0, 0, 1); // Set +Z as up
                    camera.lookAt(scene.position);
                    controls.update();

                    isFirstLoad = false;
                }

                // Update trajectory sphere and trail
                updateTrajectory(frameIndex);

            }, undefined, function(error) {
                console.error('An error occurred while loading the PLY file:', error);
            });
        }

        function updateTrajectory(frameIndex) {
            if (!trajectoryData) return;

            const position = trajectoryData[frameIndex];
            if (!position) return;

            // Update main trajectory sphere
            if (!trajectorySphereMesh) {
                const sphereGeometry = new THREE.SphereGeometry(0.25, 32, 32);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                trajectorySphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                scene.add(trajectorySphereMesh);
            }
            trajectorySphereMesh.position.set(position[0], position[1], position[2]);

            // Update trail
            const trailPositions = [];
            for (let i = 0; i < 3; i++) {
                const trailIndex = Math.max(0, frameIndex - i);
                const trailPos = trajectoryData[trailIndex];
                if (trailPos) {
                    trailPositions.push(new THREE.Vector3(trailPos[0], trailPos[1], trailPos[2]));
                    
                    if (i >= trailSphereMeshes.length) {
                        const trailSphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                        const trailSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const trailSphereMesh = new THREE.Mesh(trailSphereGeometry, trailSphereMaterial);
                        scene.add(trailSphereMesh);
                        trailSphereMeshes.push(trailSphereMesh);
                    }
                    trailSphereMeshes[i].position.copy(trailPositions[i]);
                }
            }

            // Update trail line
            if (trailLine) scene.remove(trailLine);
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(trailPositions);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            trailLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(trailLine);
        }

        function updateFrame(frameIndex) {
            frameIndex = Math.max(0, Math.min(18, frameIndex));
            slider.value = frameIndex;
            frameNumber.textContent = frameIndex;
            loadPLY(frameIndex);
        }

        slider.addEventListener('input', function() {
            updateFrame(parseInt(this.value));
        });

        document.addEventListener('keydown', function(event) {
            const currentFrame = parseInt(slider.value);
            if (event.key === 'ArrowLeft') {
                updateFrame(currentFrame - 1);
            } else if (event.key === 'ArrowRight') {
                updateFrame(currentFrame + 1);
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', function() {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
            controls.handleResize();
        });
    </script>
</body>
</html>